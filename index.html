<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dental Defense - WebXR Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js"
    }
  }
  </script>

  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #e3f2fd, #ffffff, #e1f5fe);
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #start-button {
      width: 100%;
      height: 100%;
      font-size: 120px;
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.9), rgba(3, 169, 244, 0.9));
      color: white;
      border: none;
      border-radius: 0;
      box-shadow: 0 4px 15px rgba(33, 150, 243, 0.5);
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #start-button:hover {
      background: linear-gradient(135deg, rgba(33, 150, 243, 1), rgba(3, 169, 244, 1));
      box-shadow: 0 6px 20px rgba(33, 150, 243, 0.6);
    }
    #status {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 16px;
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      padding: 12px 18px;
      border-radius: 12px;
      display: none;
      backdrop-filter: blur(8px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      border: 1px solid rgba(33, 150, 243, 0.2);
      visibility: hidden;
    }
    .webxr-hidden {
      display: none !important;
    }
    .exit-ar { 
      position: fixed; 
      top: 20px; 
      right: 20px; 
      background: rgba(255, 255, 255, 0.9); 
      color: #333; 
      border: none; 
      border-radius: 50%; 
      width: 50px; 
      height: 50px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 24px; 
      cursor: pointer; 
      backdrop-filter: blur(5px); 
      box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
      z-index: 1000; 
      display: none; 
    }
    .xr-active .exit-ar { 
      display: flex; 
    }
  </style>
</head>
<body>
  <div id="overlay">
    <button id="start-button">ðŸ¦·</button>
    <div id="status"></div>
  </div>
  
  <button class="exit-ar" id="exit-ar">Ã—</button>
  
  <audio id="clean-sound" preload="auto">
    <source src="dead.mp3" type="audio/mpeg">
  </audio>
  
  <audio id="cavity-sound" preload="auto">
    <source src="minecraft-glass-break.mp3" type="audio/mpeg">
  </audio>
  
  <script type="module">
    import * as THREE from 'three';

    let camera, scene, renderer;
    let activeController;
    let controllers = [];
    let activeControllerIndex = 0;
    let controllerPressStart = 0;
    let upperTeeth = [];
    let lowerTeeth = [];
    let upperGumLine, lowerGumLine;
    let currentToothIndex = 0;
    let currentRow = 'upper'; // 'upper' or 'lower'
    let bacteria = [];
    let clock = new THREE.Clock();
    let isPlaying = false;
    let lastControllerRotation = new THREE.Euler();
    let gameStartTime = 0;
    let xrSession = null;
    
    // Burp animation variables
    let burpStartTime = 0;
    let isBurping = false;
    let nextBurpTime = 0;
    let teethOriginalPositions = [];
    
    // Controller selection variables
    let isControllerSelectionPhase = false;
    let controllerSelectionStartTime = 0;
    let controllerHoldStartTime = {};
    let selectedController = null;
    const CONTROLLER_SELECTION_DURATION = 15000;
    const CONTROLLER_HOLD_DURATION = 4000;
    
    // Clap to exit variables
    let clapStartTime = 0;
    let isClapDetected = false;
    const CLAP_HOLD_DURATION = 2000;
    const CLAP_DISTANCE_THRESHOLD = 0.15;
    
    // Game state variables
    let score = 0;
    let bacteriaSpawnInterval = 3.0;
    let lastBacteriaSpawn = 0;
    let cleanedTeeth = new Set();
    let totalTeeth = 16; // 8 upper + 8 lower
    
    // UI elements
    let scorePanel;
    let scoreText;
    let progressText;
    let selectionIndicator;
    
    function updateStatus(message) {
      console.log('Status:', message);
    }
    
    init();

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0xf0f8ff, 0.05);
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Preload audio
      const cleanSound = document.getElementById('clean-sound');
      cleanSound.load();
      
      const cavitySound = document.getElementById('cavity-sound');
      cavitySound.load();

      // Lighting setup for dental environment
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
      directionalLight.position.set(0, 1, 1);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Dental light effect
      const spotLight = new THREE.SpotLight(0xffffff, 2, 5, Math.PI / 6, 0.5);
      spotLight.position.set(0, 0.5, 0.5);
      spotLight.target.position.set(0, 0, -1);
      scene.add(spotLight);
      scene.add(spotLight.target);

      document.getElementById('start-button').addEventListener('click', startARSession);
      document.getElementById('exit-ar').addEventListener('click', endARSession);
      window.addEventListener('resize', onWindowResize);
    }

    async function startARSession() {
      if (!navigator.xr) {
        updateStatus('WebXR not supported on this device');
        return;
      }
      
      try {
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (supported) {
          const sessionInit = {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          };
          const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
          onSessionStarted(session);
        } else {
          updateStatus('WebXR AR session is not supported on this device.');
        }
      } catch (error) {
        updateStatus('Failed to start AR session: ' + error.message);
      }
    }

    function hideUIElements() {
      document.getElementById('overlay').classList.add('webxr-hidden');
    }

    function showUIElements() {
      document.getElementById('overlay').classList.remove('webxr-hidden');
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    async function onSessionStarted(session) {
      xrSession = session;
      document.getElementById('start-button').style.display = 'none';
      document.body.classList.add('xr-active');
      
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      hideUIElements();

      updateStatus('Creating dental environment...');

      createTeeth();
      createGumLines();
      create3DUI();
      createSelectionIndicator();
      setupController(session);
      
      // Schedule first burp (much rarer - 75% reduction)
      scheduleNextBurp();

      renderer.setAnimationLoop(render);
      session.addEventListener('end', onSessionEnd);

      startControllerSelection();
    }

    function createGumLines() {
      // Create thin pink horseshoe-shaped lines above and below teeth
      const gumLineMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffc0cb, // Pink color
        roughness: 0.7,
        metalness: 0
      });
      
      // Create upper gum line - horseshoe shape above upper teeth
      const upperPoints = [];
      for (let i = 0; i <= 32; i++) {
        const angle = (i / 32) * Math.PI; // Half circle
        const radius = 0.72;
        const x = Math.sin(angle) * radius;
        const z = -1.2 - Math.cos(angle) * 0.35;
        upperPoints.push(new THREE.Vector3(x, 0, z));
      }
      
      const upperCurve = new THREE.CatmullRomCurve3(upperPoints);
      const upperLineGeometry = new THREE.TubeGeometry(upperCurve, 32, 0.008, 8, false);
      upperGumLine = new THREE.Mesh(upperLineGeometry, gumLineMaterial);
      upperGumLine.position.y = 0.38; // Just above upper teeth
      scene.add(upperGumLine);
      
      // Create lower gum line - horseshoe shape below lower teeth
      const lowerPoints = [];
      for (let i = 0; i <= 32; i++) {
        const angle = (i / 32) * Math.PI; // Half circle
        const radius = 0.72;
        const x = Math.sin(angle) * radius;
        const z = -1.2 - Math.cos(angle) * 0.35;
        lowerPoints.push(new THREE.Vector3(x, 0, z));
      }
      
      const lowerCurve = new THREE.CatmullRomCurve3(lowerPoints);
      const lowerLineGeometry = new THREE.TubeGeometry(lowerCurve, 32, 0.008, 8, false);
      lowerGumLine = new THREE.Mesh(lowerLineGeometry, gumLineMaterial.clone());
      lowerGumLine.position.y = -0.38; // Just below lower teeth
      scene.add(lowerGumLine);
    }

    function createTeeth() {
      teethOriginalPositions = [];
      
      // Create upper row of teeth in curved formation
      for (let i = 0; i < 8; i++) {
        const tooth = createTooth(i);
        
        // Create curved positioning for upper teeth
        const angle = (i - 3.5) * 0.4;
        const radius = 0.6;
        const x = Math.sin(angle) * radius;
        const z = -1.2 - Math.cos(angle) * 0.4;
        
        tooth.position.set(x, 0.25, z);
        tooth.rotation.y = -angle * 0.8;
        scene.add(tooth);
        upperTeeth.push(tooth);
        
        // Store original position for burp animation
        teethOriginalPositions.push({
          position: tooth.position.clone(),
          rotation: tooth.rotation.clone()
        });
      }
      
      // Create lower row of teeth in curved formation
      for (let i = 0; i < 8; i++) {
        const tooth = createTooth(i + 8);
        
        // Create curved positioning for lower teeth
        const angle = (i - 3.5) * 0.4;
        const radius = 0.65;
        const x = Math.sin(angle) * radius;
        const z = -1.2 - Math.cos(angle) * 0.35;
        
        tooth.position.set(x, -0.25, z);
        tooth.rotation.y = -angle * 0.8;
        scene.add(tooth);
        lowerTeeth.push(tooth);
        
        // Store original position for burp animation
        teethOriginalPositions.push({
          position: tooth.position.clone(),
          rotation: tooth.rotation.clone()
        });
      }
    }

    function createTooth(index) {
      const group = new THREE.Group();
      
      // Create realistic tooth shapes without CapsuleGeometry (not available in r128)
      let geometry;
      if (index % 8 < 2 || index % 8 > 5) {
        // Molars - wider with rounded shape using CylinderGeometry
        geometry = new THREE.CylinderGeometry(0.09, 0.08, 0.22, 12);
        // Add some irregularity to make it look more like a molar
        const positions = geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const x = positions.getX(i);
          const y = positions.getY(i);
          const z = positions.getZ(i);
          // Add slight randomness for natural molar shape
          if (Math.abs(y) < 0.1) { // Middle section
            positions.setX(i, x * (1 + Math.random() * 0.1));
            positions.setZ(i, z * (1 + Math.random() * 0.1));
          }
        }
        positions.needsUpdate = true;
      } else if (index % 8 === 3 || index % 8 === 4) {
        // Front teeth - taller and thinner using CylinderGeometry
        geometry = new THREE.CylinderGeometry(0.06, 0.05, 0.26, 12);
        // Flatten front and back for more realistic front tooth shape
        const positions = geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const z = positions.getZ(i);
          positions.setZ(i, z * 0.7); // Flatten front to back
        }
        positions.needsUpdate = true;
      } else {
        // Canines - pointed top using ConeGeometry + CylinderGeometry
        const baseGeometry = new THREE.CylinderGeometry(0.06, 0.07, 0.18, 12);
        const tipGeometry = new THREE.ConeGeometry(0.06, 0.08, 12);
        
        // Merge geometries for canine shape
        geometry = new THREE.BufferGeometry();
        const basePositions = baseGeometry.attributes.position;
        const tipPositions = tipGeometry.attributes.position;
        
        // Combine vertices
        const totalVertices = basePositions.count + tipPositions.count;
        const positions = new Float32Array(totalVertices * 3);
        
        // Add base vertices
        for (let i = 0; i < basePositions.count; i++) {
          positions[i * 3] = basePositions.getX(i);
          positions[i * 3 + 1] = basePositions.getY(i) - 0.04;
          positions[i * 3 + 2] = basePositions.getZ(i);
        }
        
        // Add tip vertices
        for (let i = 0; i < tipPositions.count; i++) {
          const j = i + basePositions.count;
          positions[j * 3] = tipPositions.getX(i);
          positions[j * 3 + 1] = tipPositions.getY(i) + 0.09;
          positions[j * 3 + 2] = tipPositions.getZ(i);
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.computeVertexNormals();
        
        baseGeometry.dispose();
        tipGeometry.dispose();
      }
      
      // Tooth material - white/ivory color with slight transparency
      const material = new THREE.MeshPhysicalMaterial({
        color: 0xfff8dc,
        roughness: 0.3,
        metalness: 0.1,
        clearcoat: 0.8,
        clearcoatRoughness: 0.2,
        transmission: 0.1,
        thickness: 0.1
      });
      
      const tooth = new THREE.Mesh(geometry, material);
      tooth.castShadow = true;
      tooth.receiveShadow = true;
      group.add(tooth);
      
      group.userData = { 
        toothIndex: index, 
        isClean: false,
        originalColor: 0xfff8dc,
        hasBacteria: false
      };
      
      return group;
    }

    function createSelectionIndicator() {
      // Create a ring to show which tooth is selected
      const geometry = new THREE.RingGeometry(0.12, 0.15, 32);
      const material = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.7
      });
      selectionIndicator = new THREE.Mesh(geometry, material);
      scene.add(selectionIndicator);
    }

    function updateSelectionIndicator() {
      const teeth = currentRow === 'upper' ? upperTeeth : lowerTeeth;
      if (teeth[currentToothIndex]) {
        const tooth = teeth[currentToothIndex];
        selectionIndicator.position.copy(tooth.position);
        selectionIndicator.position.z += 0.1;
        
        // Pulse effect
        const scale = 1 + Math.sin(clock.getElapsedTime() * 5) * 0.1;
        selectionIndicator.scale.set(scale, scale, scale);
      }
    }

    function scheduleNextBurp() {
      // Schedule next burp much rarer - 75% reduction means 4x longer intervals
      // Between 60-180 seconds instead of 15-45 seconds
      nextBurpTime = clock.getElapsedTime() + 60 + Math.random() * 120;
    }

    function triggerBurp() {
      if (isBurping) return;
      
      isBurping = true;
      burpStartTime = clock.getElapsedTime();
      
      // Burp lasts for 1.5 seconds
      setTimeout(() => {
        isBurping = false;
        scheduleNextBurp();
      }, 1500);
    }

    function updateBurpAnimation() {
      if (!isBurping) return;
      
      const elapsed = clock.getElapsedTime() - burpStartTime;
      const duration = 1.5;
      const progress = elapsed / duration;
      
      if (progress > 1) {
        // Reset to original positions
        [...upperTeeth, ...lowerTeeth].forEach((tooth, index) => {
          tooth.position.copy(teethOriginalPositions[index].position);
          tooth.rotation.copy(teethOriginalPositions[index].rotation);
        });
        
        if (upperGumLine) {
          upperGumLine.position.y = 0.38;
        }
        if (lowerGumLine) {
          lowerGumLine.position.y = -0.38;
        }
        
        return;
      }
      
      // Create burp wave
      const wave = Math.sin(progress * Math.PI * 6) * Math.sin(progress * Math.PI) * 0.15;
      const verticalShake = Math.sin(progress * Math.PI * 12) * 0.08;
      
      // Move upper teeth up and outward
      upperTeeth.forEach((tooth, index) => {
        const original = teethOriginalPositions[index];
        tooth.position.y = original.position.y + wave + verticalShake;
        tooth.position.x = original.position.x + wave * 0.5;
        tooth.rotation.z = original.rotation.z + wave * 0.3;
      });
      
      // Move lower teeth down and outward
      lowerTeeth.forEach((tooth, index) => {
        const original = teethOriginalPositions[index + 8];
        tooth.position.y = original.position.y - wave - verticalShake;
        tooth.position.x = original.position.x + wave * 0.5;
        tooth.rotation.z = original.rotation.z - wave * 0.3;
      });
      
      // Move gum lines with teeth
      if (upperGumLine) {
        upperGumLine.position.y = 0.38 + wave + verticalShake;
      }
      if (lowerGumLine) {
        lowerGumLine.position.y = -0.38 - wave - verticalShake;
      }
    }

    function createBacterium() {
      // Randomly select a tooth
      const isUpper = Math.random() > 0.5;
      const teeth = isUpper ? upperTeeth : lowerTeeth;
      const randomIndex = Math.floor(Math.random() * teeth.length);
      let targetTooth = teeth[randomIndex];
      
      // Don't spawn on already clean teeth
      if (cleanedTeeth.has(targetTooth.userData.toothIndex)) return;
      
      // Check if there are already bacteria on this tooth and find available position
      const existingBacteria = bacteria.filter(b => b.userData.currentTooth === targetTooth);
      const maxBacteriaPerTooth = 3; // Maximum bacteria per tooth
      
      if (existingBacteria.length >= maxBacteriaPerTooth) {
        // Try to find another tooth
        let attempts = 0;
        let foundTooth = false;
        while (attempts < 10 && !foundTooth) {
          const newIndex = Math.floor(Math.random() * teeth.length);
          const newTooth = teeth[newIndex];
          if (!cleanedTeeth.has(newTooth.userData.toothIndex)) {
            const existingOnNewTooth = bacteria.filter(b => b.userData.currentTooth === newTooth);
            if (existingOnNewTooth.length < maxBacteriaPerTooth) {
              targetTooth = newTooth;
              randomIndex = newIndex;
              foundTooth = true;
            }
          }
          attempts++;
        }
        if (!foundTooth) return; // No space available
      }
      
      // Create bacterium group
      const bacteriumGroup = new THREE.Group();
      
      // Body - pitch black blob
      const bodyGeometry = new THREE.SphereGeometry(0.04, 16, 16);
      const bodyMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x000000,  // Pure pitch black
        roughness: 0.9,
        metalness: 0.0,
        emissive: 0x000000,
        emissiveIntensity: 0.0
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      bacteriumGroup.add(body);
      
      // Left eye
      const eyeGeometry = new THREE.SphereGeometry(0.018, 12, 12);
      const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.02, 0.02, 0.03);
      bacteriumGroup.add(leftEye);
      
      // Right eye
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.02, 0.02, 0.03);
      bacteriumGroup.add(rightEye);
      
      // Left pupil
      const pupilGeometry = new THREE.SphereGeometry(0.008, 8, 8);
      const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      leftPupil.position.copy(leftEye.position);
      leftPupil.position.z += 0.01;
      bacteriumGroup.add(leftPupil);
      
      // Right pupil
      const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      rightPupil.position.copy(rightEye.position);
      rightPupil.position.z += 0.01;
      bacteriumGroup.add(rightPupil);
      
      // Position bacterium on tooth with spacing for multiple bacteria
      const existingCount = bacteria.filter(b => b.userData.currentTooth === targetTooth).length;
      const offsetPositions = [
        { x: 0, y: 0 },      // center
        { x: 0.06, y: 0 },   // right
        { x: -0.06, y: 0 },  // left
      ];
      const offset = offsetPositions[existingCount] || { x: 0, y: 0 };
      
      bacteriumGroup.position.copy(targetTooth.position);
      bacteriumGroup.position.x += offset.x;
      bacteriumGroup.position.y += offset.y;
      bacteriumGroup.position.z += 0.08;
      
      bacteriumGroup.userData = {
        targetTooth: targetTooth,
        timeOnTooth: 0,
        jumpTimer: 0,
        currentTooth: targetTooth,
        row: isUpper ? 'upper' : 'lower',
        index: randomIndex,
        leftPupil: leftPupil,
        rightPupil: rightPupil,
        leftEyeCenter: leftEye.position.clone(),
        rightEyeCenter: rightEye.position.clone(),
        pupilTimer: Math.random() * Math.PI * 2,
        positionOffset: offset
      };
      
      scene.add(bacteriumGroup);
      bacteria.push(bacteriumGroup);
      
      // Mark tooth as having bacterium
      targetTooth.userData.hasBacteria = true;
    }

    function updateBacteria(dt) {
      for (let i = bacteria.length - 1; i >= 0; i--) {
        const bacterium = bacteria[i];
        bacterium.userData.timeOnTooth += dt;
        bacterium.userData.jumpTimer += dt;
        bacterium.userData.pupilTimer += dt * 2;
        
        // Make bacterium bounce
        const baseY = bacterium.userData.currentTooth.position.y + bacterium.userData.positionOffset.y;
        bacterium.position.y = baseY + Math.abs(Math.sin(clock.getElapsedTime() * 3)) * 0.05;
        
        // Animate pupils moving around
        const pupilOffset = 0.006;
        const leftPupil = bacterium.userData.leftPupil;
        const rightPupil = bacterium.userData.rightPupil;
        
        leftPupil.position.x = bacterium.userData.leftEyeCenter.x + 
                              Math.sin(bacterium.userData.pupilTimer) * pupilOffset;
        leftPupil.position.y = bacterium.userData.leftEyeCenter.y + 
                              Math.cos(bacterium.userData.pupilTimer * 1.3) * pupilOffset;
        
        rightPupil.position.x = bacterium.userData.rightEyeCenter.x + 
                               Math.sin(bacterium.userData.pupilTimer * 0.8) * pupilOffset;
        rightPupil.position.y = bacterium.userData.rightEyeCenter.y + 
                               Math.cos(bacterium.userData.pupilTimer * 1.1) * pupilOffset;
        
        // Jump to another tooth every 2 seconds
        if (bacterium.userData.jumpTimer > 2.0) {
          bacterium.userData.jumpTimer = 0;
          
          // Clear current tooth's bacterium flag if this was the last one
          const remainingOnTooth = bacteria.filter(b => b.userData.currentTooth === bacterium.userData.currentTooth && b !== bacterium);
          if (remainingOnTooth.length === 0) {
            bacterium.userData.currentTooth.userData.hasBacteria = false;
          }
          
          // Jump to random nearby tooth
          const teeth = bacterium.userData.row === 'upper' ? upperTeeth : lowerTeeth;
          let newIndex = Math.floor(Math.random() * teeth.length);
          
          // Avoid cleaned teeth and find available space
          let attempts = 0;
          let foundSpot = false;
          while (attempts < 10 && !foundSpot) {
            if (!cleanedTeeth.has(teeth[newIndex].userData.toothIndex)) {
              const existingOnTooth = bacteria.filter(b => b.userData.currentTooth === teeth[newIndex]);
              if (existingOnTooth.length < 3) {
                foundSpot = true;
              } else {
                newIndex = Math.floor(Math.random() * teeth.length);
              }
            } else {
              newIndex = Math.floor(Math.random() * teeth.length);
            }
            attempts++;
          }
          
          if (foundSpot) {
            bacterium.userData.currentTooth = teeth[newIndex];
            bacterium.userData.index = newIndex;
            
            // Calculate new position with spacing
            const existingCount = bacteria.filter(b => b.userData.currentTooth === teeth[newIndex] && b !== bacterium).length;
            const offsetPositions = [
              { x: 0, y: 0 },      // center
              { x: 0.06, y: 0 },   // right
              { x: -0.06, y: 0 },  // left
            ];
            const newOffset = offsetPositions[existingCount] || { x: 0, y: 0 };
            bacterium.userData.positionOffset = newOffset;
            
            // Animate jump
            bacterium.position.x = teeth[newIndex].position.x + newOffset.x;
            bacterium.position.z = teeth[newIndex].position.z + 0.08;
            
            // Mark new tooth as having bacterium
            teeth[newIndex].userData.hasBacteria = true;
          }
        }
        
        // Create decay effect if bacterium stays too long (after 5 seconds)
        if (bacterium.userData.timeOnTooth > 5.0) {
          const tooth = bacterium.userData.currentTooth;
          const toothMesh = tooth.children[0];
          if (toothMesh && toothMesh.material) {
            // Darken the tooth gradually
            const darkness = Math.min(bacterium.userData.timeOnTooth / 10, 0.5);
            toothMesh.material.color.setRGB(1 - darkness, 1 - darkness, 0.8 - darkness);
          }
        }
      }
    }

    function cleanTooth() {
      const teeth = currentRow === 'upper' ? upperTeeth : lowerTeeth;
      const currentTooth = teeth[currentToothIndex];
      
      if (!currentTooth) return;
      
      // Check if there's a bacterium on this tooth
      let bacteriumFound = false;
      for (let i = bacteria.length - 1; i >= 0; i--) {
        const bacterium = bacteria[i];
        if (bacterium.userData.currentTooth === currentTooth) {
          // Remove bacterium
          scene.remove(bacterium);
          bacteria.splice(i, 1);
          bacteriumFound = true;
          
          // Dispose of all geometries and materials
          bacterium.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
          
          // Play clean sound
          const cleanSound = document.getElementById('clean-sound');
          cleanSound.currentTime = 0;
          cleanSound.play().catch(err => console.warn('Audio play failed:', err));
          
          // Add score
          score += 10;
          
          // Clean the tooth
          cleanedTeeth.add(currentTooth.userData.toothIndex);
          currentTooth.userData.isClean = true;
          currentTooth.userData.hasBacteria = false;
          
          // Make tooth sparkle
          const toothMesh = currentTooth.children[0];
          if (toothMesh && toothMesh.material) {
            toothMesh.material.color.set(0xffffff);
            toothMesh.material.emissive = new THREE.Color(0x88ff88);
            toothMesh.material.emissiveIntensity = 0.5;
            
            // Fade out sparkle
            setTimeout(() => {
              toothMesh.material.emissive = new THREE.Color(0x000000);
              toothMesh.material.emissiveIntensity = 0;
            }, 500);
          }
          
          // Create particle effect
          createCleanEffect(currentTooth.position);
          break;
        }
      }
      
      if (!bacteriumFound && !currentTooth.userData.isClean) {
        // No bacterium here - play error sound
        const cavitySound = document.getElementById('cavity-sound');
        cavitySound.currentTime = 0;
        cavitySound.volume = 0.3;
        cavitySound.play().catch(err => console.warn('Audio play failed:', err));
      }
    }

    function createCleanEffect(position) {
      // Create sparkle particles
      for (let i = 0; i < 10; i++) {
        const geometry = new THREE.SphereGeometry(0.01, 8, 8);
        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(0.3, 1, 0.8),
          transparent: true,
          opacity: 1
        });
        
        const particle = new THREE.Mesh(geometry, material);
        particle.position.copy(position);
        
        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.02,
          Math.random() * 0.02,
          (Math.random() - 0.5) * 0.02
        );
        
        scene.add(particle);
        
        // Animate particle
        const startTime = clock.getElapsedTime();
        const animate = () => {
          const elapsed = clock.getElapsedTime() - startTime;
          if (elapsed < 1) {
            particle.position.add(velocity);
            particle.material.opacity = 1 - elapsed;
            particle.scale.setScalar(1 - elapsed * 0.5);
            requestAnimationFrame(animate);
          } else {
            scene.remove(particle);
            particle.geometry.dispose();
            particle.material.dispose();
          }
        };
        requestAnimationFrame(animate);
      }
    }

    function startControllerSelection() {
      isControllerSelectionPhase = true;
      controllerSelectionStartTime = clock.getElapsedTime();
      selectedController = null;
      controllerHoldStartTime = {};
      
      updateStatus('Hold controller in front to start');
    }

    function checkControllerSelection() {
      if (!isControllerSelectionPhase) return;
      
      const currentTime = clock.getElapsedTime();
      const timeElapsed = (currentTime - controllerSelectionStartTime) * 1000;
      const timeRemaining = CONTROLLER_SELECTION_DURATION - timeElapsed;
      
      let highestController = -1;
      let highestY = -999;
      
      for (let i = 0; i < controllers.length; i++) {
        const controller = controllers[i];
        if (!controller.visible) continue;
        
        if (controller.position.y > highestY) {
          highestY = controller.position.y;
          highestController = i;
        }
      }
      
      for (let i = 0; i < controllers.length; i++) {
        const controller = controllers[i];
        if (!controller.visible) continue;
        
        const isInFront = controller.position.z > -0.8 && controller.position.z < -0.3 &&
                         Math.abs(controller.position.x) < 0.3 && 
                         Math.abs(controller.position.y) < 0.3;
        
        const isHighest = (i === highestController);
        
        if (isInFront && isHighest) {
          if (!controllerHoldStartTime[i]) {
            controllerHoldStartTime[i] = currentTime;
          }
          
          const holdDuration = (currentTime - controllerHoldStartTime[i]) * 1000;
          
          if (holdDuration >= CONTROLLER_HOLD_DURATION) {
            selectedController = i;
            activeController = controllers[i];
            activeControllerIndex = i;
            finishControllerSelection();
            return;
          }
        } else {
          controllerHoldStartTime[i] = null;
        }
      }
      
      if (timeRemaining <= 0) {
        selectedController = highestController >= 0 ? highestController : 0;
        activeController = controllers[selectedController];
        activeControllerIndex = selectedController;
        finishControllerSelection();
      }
    }

    function finishControllerSelection() {
      isControllerSelectionPhase = false;
      updateStatus('Game started! Clean the teeth!');
      startGame();
    }

    function checkClapToExit() {
      if (!xrSession || controllers.length < 2) return;
      
      const controller1 = controllers[0];
      const controller2 = controllers[1];
      
      if (!controller1.visible || !controller2.visible) {
        isClapDetected = false;
        clapStartTime = 0;
        return;
      }
      
      const distance = controller1.position.distanceTo(controller2.position);
      
      if (distance <= CLAP_DISTANCE_THRESHOLD) {
        if (!isClapDetected) {
          isClapDetected = true;
          clapStartTime = Date.now();
        } else {
          const holdDuration = Date.now() - clapStartTime;
          if (holdDuration >= CLAP_HOLD_DURATION) {
            updateStatus('Exiting...');
            endARSession();
            return;
          }
        }
      } else {
        isClapDetected = false;
        clapStartTime = 0;
      }
    }

    function startGame() {
      isPlaying = true;
      gameStartTime = clock.getElapsedTime();
      score = 0;
      cleanedTeeth.clear();
    }

    function endARSession() {
      if (xrSession) {
        xrSession.end();
      }
    }

    function onSessionEnd() {
      isPlaying = false;
      isControllerSelectionPhase = false;
      isClapDetected = false;
      clapStartTime = 0;
      isBurping = false;
      document.body.classList.remove('xr-active');
      showUIElements();
      document.getElementById('start-button').style.display = 'flex';
      
      clearScene();
      
      renderer.setAnimationLoop(null);
      xrSession = null;
    }

    function clearScene() {
      // Clear all teeth
      [...upperTeeth, ...lowerTeeth].forEach(tooth => {
        tooth.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        scene.remove(tooth);
      });
      upperTeeth = [];
      lowerTeeth = [];
      teethOriginalPositions = [];
      
      // Clear gum lines
      if (upperGumLine) {
        upperGumLine.geometry.dispose();
        upperGumLine.material.dispose();
        scene.remove(upperGumLine);
        upperGumLine = null;
      }
      if (lowerGumLine) {
        lowerGumLine.geometry.dispose();
        lowerGumLine.material.dispose();
        scene.remove(lowerGumLine);
        lowerGumLine = null;
      }
      
      // Clear bacteria
      bacteria.forEach(bacterium => {
        bacterium.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        scene.remove(bacterium);
      });
      bacteria = [];
      
      // Clear UI
      if (scorePanel) scene.remove(scorePanel);
      if (selectionIndicator) {
        if (selectionIndicator.geometry) selectionIndicator.geometry.dispose();
        if (selectionIndicator.material) selectionIndicator.material.dispose();
        scene.remove(selectionIndicator);
      }
    }

    function createTextTexture(text, fontSize = 48, color = '#ffffff', bgColor = 'rgba(0,0,0,0.8)') {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 128;
      
      context.fillStyle = bgColor;
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      context.strokeStyle = 'rgba(255,255,255,0.3)';
      context.lineWidth = 2;
      context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
      
      context.fillStyle = color;
      context.font = `bold ${fontSize}px Arial`;
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, canvas.width / 2, canvas.height / 2);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    function create3DUI() {
      scorePanel = new THREE.Group();
      scorePanel.position.set(0, 0.5, -1.5);
      
      // Score display
      const scoreTexture = createTextTexture('Score: 0', 42, '#ffffff', 'rgba(33, 150, 243, 0.8)');
      const scoreGeometry = new THREE.PlaneGeometry(1.2, 0.3);
      const scoreMaterial = new THREE.MeshBasicMaterial({ 
        map: scoreTexture, 
        transparent: true,
        side: THREE.DoubleSide
      });
      scoreText = new THREE.Mesh(scoreGeometry, scoreMaterial);
      scoreText.position.y = 0.2;
      scorePanel.add(scoreText);
      
      // Progress display
      const progressTexture = createTextTexture('Clean: 0/16', 42, '#ffffff', 'rgba(76, 175, 80, 0.8)');
      const progressGeometry = new THREE.PlaneGeometry(1.2, 0.3);
      const progressMaterial = new THREE.MeshBasicMaterial({ 
        map: progressTexture, 
        transparent: true,
        side: THREE.DoubleSide
      });
      progressText = new THREE.Mesh(progressGeometry, progressMaterial);
      progressText.position.y = -0.2;
      scorePanel.add(progressText);
      
      scene.add(scorePanel);
    }

    function update3DScorePanel() {
      if (!scorePanel) return;
      
      scoreText.material.map = createTextTexture(`Score: ${score}`, 42, '#ffffff', 'rgba(33, 150, 243, 0.8)');
      scoreText.material.map.needsUpdate = true;
      
      progressText.material.map = createTextTexture(`Clean: ${cleanedTeeth.size}/${totalTeeth}`, 42, '#ffffff', 'rgba(76, 175, 80, 0.8)');
      progressText.material.map.needsUpdate = true;
    }

    function setupController(session) {
      controllers = [];
      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        
        controller.addEventListener('selectstart', () => {
          if (isPlaying && !isControllerSelectionPhase && i === activeControllerIndex) {
            cleanTooth();
          }
        });
        
        scene.add(controller);
        
        // Controller visual (invisible)
        const cg = new THREE.Group();
        const geom = new THREE.SphereGeometry(0.03, 16, 16);
        const mat = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          roughness: 0.1,
          metalness: 0.1,
          clearcoat: 1.0,
          emissive: 0xffffff,
          emissiveIntensity: 0.2
        });
        const cm = new THREE.Mesh(geom, mat);
        cg.add(cm);
        cg.add(new THREE.PointLight(0xffffff, 1.5, 0.3));
        controller.add(cg);
        
        // Make controller invisible
        cg.visible = false;
        
        controllers.push(controller);
      }
    }

    function handleControllerRotation() {
      if (!activeController || !isPlaying) return;
      const rot = new THREE.Euler().setFromQuaternion(activeController.quaternion);
      const d = rot.z - lastControllerRotation.z;
      
      const sensitivity = 0.15;
      
      if (Math.abs(d) > sensitivity) {
        if (d > 0) {
          // Rotate right - move to next tooth
          currentToothIndex++;
          if (currentToothIndex >= 8) {
            currentToothIndex = 0;
            // Switch row
            currentRow = currentRow === 'upper' ? 'lower' : 'upper';
          }
        } else {
          // Rotate left - move to previous tooth
          currentToothIndex--;
          if (currentToothIndex < 0) {
            currentToothIndex = 7;
            // Switch row
            currentRow = currentRow === 'upper' ? 'lower' : 'upper';
          }
        }
      }
      
      // Also allow vertical rotation to switch rows
      const verticalD = rot.x - lastControllerRotation.x;
      if (Math.abs(verticalD) > sensitivity) {
        currentRow = verticalD > 0 ? 'upper' : 'lower';
      }
      
      lastControllerRotation.copy(rot);
    }

    function checkWinCondition() {
      if (cleanedTeeth.size >= totalTeeth) {
        // All teeth cleaned!
        isPlaying = false;
        
        // Victory effect
        const victoryText = createTextTexture('ðŸŽ‰ Perfect Smile! ðŸŽ‰', 60, '#ffff00', 'rgba(76, 175, 80, 0.9)');
        const victoryGeometry = new THREE.PlaneGeometry(2, 0.5);
        const victoryMaterial = new THREE.MeshBasicMaterial({ 
          map: victoryText, 
          transparent: true,
          side: THREE.DoubleSide
        });
        const victoryMesh = new THREE.Mesh(victoryGeometry, victoryMaterial);
        victoryMesh.position.set(0, 0, -1);
        scene.add(victoryMesh);
        
        // Make all teeth sparkle
        [...upperTeeth, ...lowerTeeth].forEach(tooth => {
          const toothMesh = tooth.children[0];
          if (toothMesh && toothMesh.material) {
            toothMesh.material.emissive = new THREE.Color(0xffff88);
            toothMesh.material.emissiveIntensity = 0.3;
          }
        });
        
        // Restart after 5 seconds
        setTimeout(() => {
          scene.remove(victoryMesh);
          victoryMesh.geometry.dispose();
          victoryMesh.material.dispose();
          resetGame();
        }, 5000);
      }
    }

    function resetGame() {
      // Reset game state
      score = 0;
      cleanedTeeth.clear();
      currentToothIndex = 0;
      currentRow = 'upper';
      gameStartTime = clock.getElapsedTime();
      isPlaying = true;
      
      // Reset burp timing
      scheduleNextBurp();
      
      // Reset teeth appearance
      [...upperTeeth, ...lowerTeeth].forEach(tooth => {
        tooth.userData.isClean = false;
        tooth.userData.hasBacteria = false;
        const toothMesh = tooth.children[0];
        if (toothMesh && toothMesh.material) {
          toothMesh.material.color.set(0xfff8dc);
          toothMesh.material.emissive = new THREE.Color(0x000000);
          toothMesh.material.emissiveIntensity = 0;
        }
      });
      
      // Clear existing bacteria
      bacteria.forEach(bacterium => {
        scene.remove(bacterium);
        bacterium.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
      });
      bacteria = [];
    }

    function render(time, frame) {
      const dt = Math.min(clock.getDelta(), 1/30);
      
      if (frame) {
        // Check clap to exit
        if (!isControllerSelectionPhase) {
          checkClapToExit();
        }
        
        // Handle controller selection
        if (isControllerSelectionPhase) {
          checkControllerSelection();
        }
        
        // Handle gameplay
        if (isPlaying && !isControllerSelectionPhase) {
          handleControllerRotation();
          updateSelectionIndicator();
          updateBacteria(dt);
          update3DScorePanel();
          
          // Check for burp trigger
          if (!isBurping && clock.getElapsedTime() >= nextBurpTime) {
            triggerBurp();
          }
          
          // Update burp animation
          updateBurpAnimation();
          
          // Spawn bacteria
          if (clock.getElapsedTime() - lastBacteriaSpawn > bacteriaSpawnInterval) {
            createBacterium();
            lastBacteriaSpawn = clock.getElapsedTime();
            // Gradually increase difficulty
            bacteriaSpawnInterval = Math.max(1.5, bacteriaSpawnInterval - 0.05);
          }
          
          // Check win condition
          checkWinCondition();
        }
      }
      
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
